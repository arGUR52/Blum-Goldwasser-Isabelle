theory BG_aux 
imports Sigma_Commit_Crypto.Number_Theory_Aux 
begin 

section "Auxillary Lemmas"

text "Here, we have all the auxillary definitions used in the formalization of Blum-Goldwasser cryptosystem"


section "Auxillary Lemmas"

text "Here, we have all the auxillary lemmas used to prove the correctness of Blum-Goldwasser cryptosystem"

(*Euler's criterion does not exist in Isabelle, should be proven.
  This is just a preliminary attempt at proving it - going to look into it 
  further after the formalization is done *)



(*split if_splits safe goal_cases*)
lemma eulers_criterion:
  assumes "prime (p :: nat)" "odd p" "\<not> p dvd x" "(\<exists>y. y^2 = x)"
  shows "[x^((p - 1) div 2) = 1] (mod p)"
proof -
  from assms(2) have even_p_minus_one: "even (p - 1)" by auto
  then have "(\<exists>k. p - 1 = 2 * k)"  by blast
  then obtain k where obtain_k:"p - 1 = 2 * k" by blast

  from assms(1) assms(3) fermat_theorem 
  have "[x^(p - 1) = 1] (mod p)"
    by algebra
  then have "[x^((p - 1) div 2) * x^((p - 1) div 2) = 1] (mod p)" 
  using dvd_div_mult_self even_p_minus_one power2_eq_square power_mult
  by (metis)
  then have trial: "[x^((p - 1) div 2) = 1] (mod p) \<or> [x^((p - 1) div 2) = -1] (mod p)" 
    by (metis assms(1) assms(3) assms(4) div_mult_self1_is_m fermat_theorem 
    obtain_k pos2 power_mult prime_dvd_power_nat_iff)

  (*then have before_split: "[x^(2 * k) - 1 = 0] (mod p)" using obtain_k by auto
  
  have "(x^(2 * k) - 1 = (x ^ k - 1) * (x ^k + 1))"
    by (auto simp add: mult.commute power2_eq_square right_diff_distrib' power_mult)
  from this before_split have after_split: "[(x ^ k - 1) * (x ^k + 1) = 0] (mod p)" 
    by auto*)

  from assms(4) obtain y where obtain_y: "y^2 = x" by blast
  from trial obtain_y have "[(y^2)^((p - 1) div 2) = 1] (mod p) \<or> [(y^2)^((p - 1) div 2) = -1] (mod p)"
    by auto
  have "\<not> [(y^2)^((p - 1) div 2) = -1] (mod p)" 
  proof (rule ccontr)
    assume "\<not> \<not> [(y^2)^((p - 1) div 2) = -1] (mod p)"
    then have "[(y^2)^((p - 1) div 2) = -1] (mod p)" by auto
    then have "[(y)^(((p - 1) div 2) * 2) = -1] (mod p)" using power_mult
      by (metis mult.commute)
    then have y_minus_one: "[(y)^(p - 1) = -1] (mod p)"
      using even_p_minus_one by auto
    have "\<not> p dvd y" 
      using obtain_y assms(3) assms(1) pos2 prime_dvd_power_iff by blast
    then have "[(y)^(p - 1) = 1] (mod p)"
      using fermat_theorem assms(1) by auto
    from this y_minus_one have contradiction: "[(y)^(p - 1) = -1] (mod p) \<and> [(y)^(p - 1) = 1] (mod p)" by auto

    have "\<not> [1 = -1] (mod p)" 
    proof (rule ccontr)
      assume "\<not>\<not> [1 = -1] (mod p)" 
      then have "[1 = -1] (mod p)" by auto
      then have "p dvd 1 - (-1)" using cong_iff_dvd_diff 
        by fast
      then have "p dvd 2" by presburger
      then show "False" 
        using assms(2) assms(1) primes_dvd_imp_eq two_is_prime_nat by blast
    qed 
    from contradiction have "[-1 = (y)^(p - 1)] (mod p) \<and> [(y)^(p - 1) = 1] (mod p)" 
      using cong_sym_eq by auto
    then have "[-1 = (y)^(p - 1)] (mod p) \<and> [int (y)^(p - 1) = int 1] (mod p)" 
      using cong_int_iff int_ops(2) by force
    then have "[-1 = 1] (mod p)" using cong_trans by auto
    
    from this contradiction show "False" using cong_int_iff   int_ops(2)
      sorry
    

     

  (*from after_split obtain_y have "[((y^2) ^ k - 1) * ((y^2) ^ k + 1) = 0] (mod p)" by auto 
  then have "[(y ^ (2*k) - 1) * (y ^ (2*k) + 1) = 0] (mod p)" using power_mult[symmetric] by metis
  then have 

  from this assms have p_coprime_to_y: "\<not> p dvd y" 
    by (auto simp add: prime_dvd_power_nat_iff)
  from obtain_y fermat_theorem_simplified have "[(y^2)^(p - 1) - 1 = 0] (mod p)" by auto
  then have "[y^(2 * (p - 1)) - 1 = 0] (mod p)" 
    by (simp add: power_mult)
  then have before_split: "[(y^(p - 1))^2 - 1 = 0] (mod p)"    
    by (simp add: power_even_eq)
  have "(y^(p - 1))^2 - 1 = (y^(p - 1) - 1) * (y ^ (p - 1) + 1)" 
    by (simp add: mult.commute power2_eq_square right_diff_distrib')
  from this before_split have "[(y^(p - 1) - 1) * (y^(p - 1) + 1) = 0] (mod p)" 
    by auto *)
  
qed




end